from telegram import Bot
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes
import pytesseract
from PIL import Image
import re
import os
import tempfile
import asyncio
import nest_asyncio

# Aplicar nest_asyncio para evitar conflictos de bucles
nest_asyncio.apply()

# Variable global saldo
saldo = 0

# ID user que acredita pagos
USER_ID_RESTA = int(os.getenv("useresta"))

# Validación de las variables de entorno
TOKEN = os.getenv("tokenbot")
WEBHOOK_URL = os.getenv("webhook_url")
PORT = int(os.getenv("port", 8443))

if not TOKEN:
    raise ValueError("Falta configurar la variable de entorno 'tokenbot'.")

if not WEBHOOK_URL or not WEBHOOK_URL.startswith("https://"):
    raise ValueError("Falta configurar una URL HTTPS válida en 'WEBHOOK_URL'.")

if not PORT:
    raise ValueError("Falta configurar el puerto en 'PORT'.")

# Crear instancia del bot
bot = Bot(token=TOKEN)

# Configuración del webhook inicial


async def configure_webhook(bot, webhook_url):
    webhook_info = await bot.get_webhook_info()  # Usa await aquí
    if webhook_info.url != webhook_url:
        print("Configurando webhook...")
        await bot.set_webhook(url=webhook_url)
    else:
        print("El webhook ya está configurado correctamente.")

# Conversión Tess


def extract_amount_from_receipt(image_path, user_id):
    text = pytesseract.image_to_string(Image.open(image_path), lang='eng')

    # regex importe
    match = re.search(r'\$\s?([\d.,]+)', text)
    if match:
        # Replace commas with periods and convert to float
        amount = float(match.group(1).replace('.', '').replace(',', '.'))
        # Restar el importe si es del usuario que resta
        if user_id == USER_ID_RESTA:
            amount = -abs(amount)
        return amount
    else:
        return None

# Función texto


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global saldo
    user_id = update.effective_user.id

    if update.message.chat.type != "group":
        await update.message.reply_text("Este bot solo funciona en grupos.")
        return

    try:
        # Intentar convertir el mensaje a un número
        numero = float(update.message.text)

        # Si el mensaje es del usuario que resta, cambiar el signo
        if user_id == USER_ID_RESTA:
            numero = -abs(numero)

        saldo += numero
        # Mostrar el saldo con formato adecuado
        saldo_mostrar = f"{saldo:,.2f}".replace(
            ',', 'X').replace('.', ',').replace('X', '.')
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"Saldo: $ {saldo_mostrar}"
        )
    except ValueError:
        pass  # Ignorar mensajes que no sean números

# Función para manejar imágenes de comprobantes


async def handle_image(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global saldo
    user_id = update.effective_user.id
    photo = update.message.photo[-1]
    file = await photo.get_file()

    # Usar un directorio temporal adecuado
    try:
        with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as temp_file:
            image_path = temp_file.name
            await file.download_to_drive(image_path)

        amount = extract_amount_from_receipt(image_path, user_id)
    finally:
        if os.path.exists(image_path):
            os.remove(image_path)

    if amount:
        saldo += amount
        saldo_mostrar = f"{saldo:,.2f}".replace(
            ',', 'X').replace('.', ',').replace('X', '.')
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"Saldo: $ {saldo_mostrar}"
        )
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="No se encontró un importe válido en el comprobante."
        )

# Función para mostrar el saldo compartido


async def show_saldo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global saldo
    saldo_mostrar = f"{saldo:,.2f}".replace(
        ',', 'X').replace('.', ',').replace('X', '.')
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"Saldo: $ {saldo_mostrar}"
    )

# Función para iniciar el bot


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Listo para operar."
    )

# Función para mostrar el estado del webhook


async def webhook_status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    webhook_info = await bot.get_webhook_info()
    await update.message.reply_text(
        f"Webhook URL: {webhook_info.url}\nPending Updates: {webhook_info.pending_update_count}"
    )

# Manejo global de errores


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    print(f"Ocurrió un error: {context.error}")
    if update:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Ha ocurrido un error, intenta de nuevo más tarde."
        )

if __name__ == "__main__":
    async def main():
        # Configura el webhook antes de iniciar el bot
        await configure_webhook(bot, WEBHOOK_URL)

        application = ApplicationBuilder().token(TOKEN).build()

        # Comandos
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("saldo", show_saldo))
        application.add_handler(CommandHandler(
            "webhook_status", webhook_status))

        # Manejador de mensajes de texto
        application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND, handle_message))

        # Manejador de imágenes
        application.add_handler(MessageHandler(
            filters.PHOTO, handle_image))

        # Manejador global de errores
        application.add_error_handler(error_handler)

        # Inicia el bot con webhooks
        print("Bot en ejecución con webhooks...")
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            webhook_url=WEBHOOK_URL
        )

    asyncio.run(main())
